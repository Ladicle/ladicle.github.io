<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Exception();</title>
    <link>//ladicle.github.io/post/</link>
    <description>Recent content in Posts on Exception();</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <lastBuildDate>Sun, 21 Aug 2016 16:14:55 +0900</lastBuildDate>
    
	<atom:link href="//ladicle.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>OSX上でTWE-LITEによるドアセンサをつくる (1) - 準備編 -</title>
      <link>//ladicle.github.io/post/tocos-door-sensor1/</link>
      <pubDate>Sun, 21 Aug 2016 16:14:55 +0900</pubDate>
      
      <guid>//ladicle.github.io/post/tocos-door-sensor1/</guid>
      <description>開閉センサの情報をTWE-Lite-DIP(下写真)とToCoSTICKでとばし、OSX上で制御する。
(TOCOStickは既に生産を終了し、後継のMONOStickが発売されている。)
概要  準備編 ⇦ 今回  ドライバのインストール jenprogでファームウェアを書き込む TWE-Lite-DIP(センサ側)の設定を書き換える ToCoSTICK(受信側)の設定を書き換える  電子工作編  開閉センサの回路をつくる 動作を確認する  制御編  センサデータを読み取るプログラムを書く ドアの開閉をSlackに通知する   1. ドライバのインストール  FTDICHIPのサイトから該当のドライバをダウンロードする (直リンクはこちら) FTDICHIPUSBSerialDriver_10_4_10_5_10_6_10_7をインストール TOCOSTICをMacにさし、USBデバイスが認識していることを確認する
$ ls /dev/tty.usb* crw-rw-rw- 1 root wheel 18, 2 8 21 12:55 /dev/tty.usbserial-AHXMZWKX  TOCOSTICKをMACから抜く
  2. jenprogでファームウェアを書き込む  TWE-LITE R単体をUSBケーブルでMACとつなげる 認識したことを確認する  $ ls /dev/tty.usb* crw-rw-rw- 1 root wheel 18, 6 8 21 13:23 /dev/tty.usbserial-AHYJH3IH  pyserialとTWE-SDKをインストールする</description>
    </item>
    
    <item>
      <title>Jenkins勉強会#9で発表してきた</title>
      <link>//ladicle.github.io/post/jenkins-study9/</link>
      <pubDate>Thu, 11 Aug 2016 23:39:14 +0900</pubDate>
      
      <guid>//ladicle.github.io/post/jenkins-study9/</guid>
      <description> コンテナCIとJobの管理方法について話してきた。
話した内容や質問された内容を補足する。
スライドはこちら。
 コンテナCIの流れ ありがちではあるが、以下の通り。
 GitHubへ変更内容をPush or PRのコメント欄にtest this pleaseと記述 上記のイベントをトリガとしてJenkinsのJobが実行 試験内容はJenkinsではなく、Kubernetes上のコンテナで実行 試験結果をSlackに通知する  環境構成  図は、分かりやすさを優先してだいぶ省略している
 試験の目的は、OpenStackの1コンポーネントに対して入れた修正の動作確認。 そのため、他のコンポーネントについては基本修正が入らない。 修正が行われるコンポーネントのみコンテナ化して、他のものはVM上に固定で作っている。 これは、コンテナ化には初期コスト&amp;amp;起動時間を回避するためだ。
 VMはOpenStackのNovaで作ったものなので、OpenStack上に試験用OpenStackがいる
 Job構成 ITとUTは並列して走るようになっており、
どちらかの試験がコケた段階でもう一方の試験も停止して結果を返す。
また、コンテナの後片付けは試験の開始時に行っている。 試験の最後にコンテナを片付けてしまうと、 試験に失敗した時の解析ができなくなってしまうためである。
Job管理 チームでは、Jenkins Job Builder(略してJJB)というYAML(/JSON)でJobを定義できるものを使用している。 Jenkinsの2.0がオススメしているJenkinsfileを使えばGitでJobを管理できるが、 昔のPluginを全て捨てPiplineに移行するのは大変であるし、 Jenkinsfileの指定には結局GUIが必要になってしまう。 しかし、JJBなら全てをCLI上で完結することができる。
YAMLのキーはJenkinsJob設定のXMLファイルと要素がほぼ一致しているので、 Jenkinsに慣れている人であれば、すぐに書けるようになると思う。
Jobの反映フロー  JJBのDocument or Code参照しつつYAMLを書く 適用して動作を見る GitHubのPRをつくる メンバーにレビューしてもらう Mergeされる Mergeイベントを契機に、Jenkinsが自身に対してMasterのJob定義を反映する  </description>
    </item>
    
    <item>
      <title>k8sをUbuntu14.04から16.04に移行した</title>
      <link>//ladicle.github.io/post/systemd-for-upstart/</link>
      <pubDate>Tue, 09 Aug 2016 19:42:46 +0900</pubDate>
      
      <guid>//ladicle.github.io/post/systemd-for-upstart/</guid>
      <description>Kubernetesを14.04から16.04に移行した。
もともとAnsibleでk8sのクラスタは構築していたのでplaybookを修正していったが、 修正点のほとんどは、UpstartファイルをSystemdファイルの書き換えだけだった。
 元にしているk8sのansibleはkubernetes/contribのansibleディレクトリにある ubuntu16.04対応のPRはそのうち&amp;hellip;
 What is Systemd? Systemdを真面目に触るのが初めてだったのでここから始めた。 以下ページを参考にした。
 Systemd入門(1) - Unitの概念を理解する Systemd入門(2) - Serviceの操作方法 Systemd入門(3) - cgroupsと動的生成Unitに関する小ネタ Systemd入門(4) - serviceタイプUnitの設定ファイル Systemd入門(5) - PrivateTmpの実装を見る   (4)はgroupなど変わっているので参考程度
 File path UbuntuはFedoraとファイルパスなどが微妙に違い、 システムデフォルト設定は/usr/lib/systemd/systemではなく/lib/systemd/systemにある。
EnvironmentFile EnvironmentFile=-/etc/sysconfig/whatever  -の有無によってファイルが存在しなかった時の動作が以下のように変わる。(参考)
 有りの場合: ファイルが存在しなかった場合も無視 無しの場合: ファイルが存在しないとエラーを発生させる   複数ファイルを読み込む時は複数のEnvironmentFileを定義する
 Convert upstart file to systemd file 公式で変換方法についてわかりやすいドキュメントが公開されている。 ざっくりとした移行手順は以下の通り(細かいところは上記リンク参照)
 設定ファイルを/etc/sysconfigに移行しEnvironmentFileで読み込み。 start onの依存関係はUnitのAfterに書き換え pre-startコマンドはServiceのExecStartPreに書き換え execコマンドはServiceのExecStartに書き換え  Sample Upstart file description &amp;quot;Kube-Apiserver service&amp;quot; respawn # start in conjunction with etcd start on started etcd stop on stopping etcd pre-start script # see also https://github.</description>
    </item>
    
    <item>
      <title>Golang 1.7 release party in Tokyo</title>
      <link>//ladicle.github.io/post/golang1.7-release-party/</link>
      <pubDate>Mon, 08 Aug 2016 19:48:11 +0900</pubDate>
      
      <guid>//ladicle.github.io/post/golang1.7-release-party/</guid>
      <description>補欠だったので無理かと思っていたら、当日繰り上がった。 イベントページはこちら
1. What&amp;rsquo;s new Go1.7? by @deeeet Golang1.7、残念ながらRelease表明されなかった(1.6の時以来2回目)
2. Release note points  MacOS Sierraをサポート Linkerが速くなった(特にk8sのような大規模のコードへの恩恵は大きい) StackFrameが入り、LinuxのProfilerが使えるようになった -Xオプションをつけると、key=valueでつなげないものはエラーになる vendoring optionが使えなくなった // go-binary-only-packageを付けるとバイナリだけを提供できるようになった 標準パッケージは以下のようなものが変更された(他にもあるよ)  context: 今まで標準ではなかった testing: subtestとbenchmarkが作成できる http tracing: httpリクエストの各ステップにフック関数の挿入が可能に    所感
HTTP tracingデバッグとチューニングにとても便利そう
 3. About contribution of Go by @stanaka  GolangへのContribution方法(前回のGoConと同じ!) まずはContribution Guidlineをよむ GitHubではなくGerritを使う(FIX, DONEなコンパクトなコメントを返せる)   所感
未だにGerrit慣れないが、コメントボタンよさそう
 4. context package by @ono_matope スライドはこちら
 1.7に標準パッケージに入ったが2014年にはPJが始まっていた 様々なライブラリのキャンセル要求インタフェースの標準か  ここら辺参照: このへんにキャンセルの話とか書いてある ▶ Go Concurrency Patterns: Pipelines and cancellation - The Go Blog https://t.</description>
    </item>
    
    <item>
      <title>Golangのバイナリに静的ファイルを組み込む</title>
      <link>//ladicle.github.io/post/pack-staic-file-to-binary-for-golang/</link>
      <pubDate>Sat, 06 Aug 2016 10:06:25 +0900</pubDate>
      
      <guid>//ladicle.github.io/post/pack-staic-file-to-binary-for-golang/</guid>
      <description>markdownをgithubスタイルのHTMLに変換するmark2hというものを作成したが、 使用するCSSやHTMLのテンプレートはバイナリに組み込まないとパスが変わった時に反映されなくなってしまう。 今回は、go-bindataを使って静的ファイルをGoのバイナリに組み込んでみる。
go-bindataを使う  go-bindataのinstall  $ go get -u github.com/jteeuwen/go-bindata/...   静的ファイルを格納するディレクトリを作る(名前は適当なもの)  $ mkdir assets   go-bindataを実行する  $ go-bindata -o assets.go assets   template読み込み部分を置き換える  1 file changed, 2 insertions(+), 2 deletions(-) diff --git a/main.go b/main.go index 1b2ec1a..8d5cfdb 100644 --- a/main.go +++ b/main.go @@ -55,13 +55,13 @@ func main(){ os.Exit(0) } - tpl, err := ioutil.ReadFile(&amp;quot;markdown.html&amp;quot;) + tpl, err := Asset(templatePath) if err !</description>
    </item>
    
    <item>
      <title>Hugoで記事と固定ページを書く</title>
      <link>//ladicle.github.io/post/write-post-by-hugo/</link>
      <pubDate>Fri, 05 Aug 2016 16:43:31 +0900</pubDate>
      
      <guid>//ladicle.github.io/post/write-post-by-hugo/</guid>
      <description>前回は、Hugoのインストール方法とテーマの変更方法について説明した。 今回は記事の作成と配信方法について解説する。
記事を書く 記事の作成には、前回作成したレポジトリのルートでnewコマンドを使う。
$ hugo new post/&amp;lt;post-title&amp;gt;.md  実行すると、content/postディレクトリに&amp;lt;post-title&amp;gt;.mdが作成されている。
$ cat content/post +++ date = &amp;quot;2016-08-05T07:48:33+09:00&amp;quot; description = &amp;quot;&amp;quot; title = &amp;quot;test&amp;quot; +++  この時、draftオプションをつけてserverを起動させると、 リアルタイムに編集内容を確認することができる。
$ hugo server -builDrafts  記事をサクッと作成する hugoコマンドはレポジトリのルートでしか動かないが、 書きたいことを思いついた時レポジトリルートにいるとは限らないので、 このようなスクリプトを.zshrcに登録している。
function blog() { postPath=/Users/ladicle/Develop/src/github.com/Ladicle/blog/content/post if [ $# -eq 0 ]; then BLOG_FILES=$(ag -l &#39;draft = true&#39; $postPath) elif [ $1 = &#39;-p&#39; ]; then BLOG_FILES=$(ag -l &#39;draft = false&#39; $postPath) elif [ $1 = &#39;-a&#39; ]; then BLOG_FILES=$(\ls $postPath) else cat&amp;lt;&amp;lt;EOF &amp;gt; $postPath/$1.</description>
    </item>
    
    <item>
      <title>Apache Mesos勉強会に行ってきた</title>
      <link>//ladicle.github.io/post/apache-mesos/</link>
      <pubDate>Thu, 04 Aug 2016 20:22:57 +0900</pubDate>
      
      <guid>//ladicle.github.io/post/apache-mesos/</guid>
      <description>MesosはKubernetesと比較されることが多いので気になっていた。
イベントのURLはこちら。
1. Mesos とは何か 木内さん @クリエーションライン
概要  DCOS(ﾃﾞｨｰｼｰｵｰｴｽ)と呼べ YARN日書いが、YARNはHadoopのためのジョブスケジューラ Mesosはサービス基盤の運用を目的にしている(対象範囲が広い) Mesos is cluster of cluster Dockerとの統合をサポート
  コンテナ化すると分業が可能  データセンタチーム : 実行基盤の配置だけ インフラチーム : リソースの稼働状況だけ アプリケーションチーム : コンテナの内容だけ   この手の物は作業が少なくなるというより
(むしろ見るコンポーネントは増えていることが多々) 分業できるところに利点を置いてるので、小さいチームもしくは大きいチームでも分業されないと 運用負荷は上がるばかりだと思う
 2. Docker ホスティングサービス &amp;lsquo;Arukas&amp;rsquo; での Mesos + Marathon の活用について 山田 修司 さん @さくらインターネット
 構成  Zookeeper Master Slave: executor実行, CPU情報の送信  k8s VS Mesos k8sはセットアップ簡単だけどシングルテナント向けでコンテナOnly。
 k8sのMultiTenant話はここら辺にある。
セットアップ楽という話が出ていたが&amp;hellip;。(Mesosがものすごくツライのかもしれない)
 Twitterでの議論 Mesos+Marathonはなぜヘビー級に汚れる環境向けなのかの説明が結局なかった気がするが、なんでだろ。環境が分離されるから、がその理由だった?</description>
    </item>
    
    <item>
      <title>Kindle Unlimitedの技術本</title>
      <link>//ladicle.github.io/post/kindle-unlimited/</link>
      <pubDate>Wed, 03 Aug 2016 12:33:51 +0900</pubDate>
      
      <guid>//ladicle.github.io/post/kindle-unlimited/</guid>
      <description> Kindle Unlimitedが今日から開始した。
持っている本や良みたかった本が登録されていたのでまとめてみた。
Technology        
 オンラインジャッジではじめるC/C++プログラミング入門 : 読みたい プログラミングコンテスト・チャレンジブック : パズルとして楽しめる Write Portable Code : 読みたい Code Craft : 読みたい 世界で闘うプログラミング力を鍛える150問 : よい本。コーディング面接に最適 :) 30日でできる! OS自作入門 : 学生のときに読んだ。ただしフロッピーなのでここら辺参照 プログラミングコンテスト攻略のためのアルゴリズムとデータ構造: 読みたい アジャイルな見積もりと計画づくり : ザッとでも読むと感覚がわかる  Others 
 ウトライン・プロセッシング入門 : 後で読む  所感  実際に読まれたページ数に対応した金額が著者に支払われるようだが
揉めそうな予感しかない。
 </description>
    </item>
    
    <item>
      <title>Pull RequestテンプレートでPRの品質を保つ</title>
      <link>//ladicle.github.io/post/add-github-templates/</link>
      <pubDate>Tue, 02 Aug 2016 15:19:34 +0900</pubDate>
      
      <guid>//ladicle.github.io/post/add-github-templates/</guid>
      <description> GitHubにContribution Guideの表示やPull Requestのテンプレートを導入してから RPの品質やレビューの水準が一定に保たれたと感じている。
Pull Requestのテンプレートを追加する 2016年の2月からGitHubがテンプレート機能をサポートした。(黒魔術なスクリプトは不要!) 使い方は簡単で、レポジトリのroot、又は.github/ディレクトリにPULL_REQUEST_TEMPLATE.mdを配置するだけだ。
現在は以下のようなテンプレートを使用している。
$ cat .github/PULL_REQUEST_TEMPLATE.md ## Ticket * https://[jira-host]/[ticket-id] ## Changes * ## Check lists * [ ] XXXの時はYYYを行う * [ ] 上記に該当しないため不要  PRのブランチ名にはJIRAのチケット番号を入れているため目的やReviewerの指定は省略した。 重点的にRVしてほしいポイントのみ記述する方式だ。 また、どうしても自動化できないタスクはチェックリストにして実施漏れを防いでいる。
 Note
* IssueのテンプレートもISSUE_TEMPLATE.mdで作成できる
* 拡張子は.mdや.txt、.org等READMEと同じくだいたい使える
 Contribution Guideを表示する Contribution GuideはCONTRIBUTING.mdファイルをレポジトリに配置するだけだ。 PR作成時、以下のようなリンクが表示されるようになる。
 Note
* CONTRIBUTION.mdはルートに配置する方が見られる機会が増えるので良いと思う
* 同じく拡張子は変更可能
 </description>
    </item>
    
    <item>
      <title>コンテナとDockerについて思うこと</title>
      <link>//ladicle.github.io/post/docker-left-oci/</link>
      <pubDate>Mon, 01 Aug 2016 21:52:39 +0900</pubDate>
      
      <guid>//ladicle.github.io/post/docker-left-oci/</guid>
      <description> ガチャピン先生のDocker、OCIやめるってよの記事が話題だったので、 コンテナとDockerについて思ったことを書いてみる。
コンテナ = Dockerか? Dockerによってコンテナが多くの人に使われるようになったのは確かだ。
しかし、コンテナ = Dockerか? という訳ではないと思う。
単純なコンテナの利点の利用&amp;mdash;
例えば、『コンテナ化して各アプリケーションを隔離したい。』と思った時、 DockerはLinuxコンテナの技術を複雑に組み合わせたDockerはオーバースキルであることが多い。
Dockerのよさ Dockerによってコンテナが流行(?)した理由として以下のようなものが考えられる。
  技術の隠蔽化 DockerHubの存在   Linuxコンテナ技術自体は昔から利用されていたが、 これらが統合されてDockerという形でラッピングされたことによって、 アプリケーションレイヤのエンジニアにとっても使いやすいものとなった。
また、DockerHubはDockerが流行に一躍をかっている。 様々なアプリケーションがDockerHubに登録されたことによって、 今までコンテナというものに触れたことがなかった人でも
$ docker run nginx  という簡単なコマンドだけで
『コンテナという技術によって簡単にアプリケーションが立ちがる』
という体験ができる。
(brewやaptのようなパッケージマネージャのように)
参考になる  こういう文脈で I agreeではじまってるときは、たいていagreeしてない
 </description>
    </item>
    
    <item>
      <title>Hugoで静的なブログを作成する</title>
      <link>//ladicle.github.io/post/hugo-de-blog/</link>
      <pubDate>Sun, 31 Jul 2016 21:46:40 +0900</pubDate>
      
      <guid>//ladicle.github.io/post/hugo-de-blog/</guid>
      <description>このブログはHugoを使用してGithub.io上に建てている。
静的Webサイトジェネレータは有名どころだとRailsのJekyllやOctopress、PythonのPelican、NodeのHexoなどが存在するが、 Hugoは速さを売りにしている。
Why Hugo?  Golangで書かれている。I&amp;rsquo;m gopher!! モダンなThemesが揃っている  Hugoをインストールする  brew install hugoを実行してhugoをインストール1 hugoコマンドでサイトのベースを作成する  $ hugo new site &amp;lt;YOUR_SITE_NAME&amp;gt; $ tree . . ├── archetypes: : 独自のプロパティ定義 ├── config.toml : サイトのTitleや説明、テーマなど全体設定のファイル ├── content : ブログ記事等、サイトの中身を格納する ├── data : TOML, JSONなどの設定ファイル ├── layouts : 静的サイトを作成する時の変換レイアウトの指定 ├── static : CSSやJavaScriptを配置する └── themes : サイトのテーマを格納する 6 directories, 1 file   hugo serverで起動し、localhost:1313にアクセスする   1. OSX以外の場合はReleasesから該当のバイナリをDLしてPathを通す
 テーマを変更する テーマのここ一覧はここで見ることができる。</description>
    </item>
    
    <item>
      <title>hello world</title>
      <link>//ladicle.github.io/post/hello-world/</link>
      <pubDate>Fri, 15 Jul 2016 17:23:37 +0900</pubDate>
      
      <guid>//ladicle.github.io/post/hello-world/</guid>
      <description>My name is Ladicle. I&amp;rsquo;m a software engineer. I develop cloud services. My interesting things are distributed system, CI, web application architecture.
This blog is generated by hugo :)</description>
    </item>
    
  </channel>
</rss>